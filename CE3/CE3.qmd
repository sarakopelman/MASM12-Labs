---
title: "CE3"
author: "Markus Gerholm, Sara Kopelman, Erik Göransson"
format: html
editor: visual
---

# CE3

## Part 1: Simulation and discretization of diffusion processes

## Question 1a

```{r}
# Parameters
delta <- 2^(-9)
theta <- c(0.7, 0.8, 3.0, -0.34)
sigma <- c(0, 0.1, 0.2, 0.3, 0.4)
N <- 100/delta
```

## Simulating Y

```{r}
Y_1 <- rep(NA, N)
Y_2 <-rep(NA,N)
Y_1[1] <- -1.9
Y_2[1] <- 1.2

for(t in 2:N){
  Y_1[t] <- Y_1[t-1] + theta[3] * (Y_1[t-1] + Y_2[t-1] - (Y_1[t-1]^3)/3 + theta[4]) * delta + sigma[4] * sqrt(delta) * rnorm(1)
  Y_2[t] <- Y_2[t-1] - ((Y_1[t-1] + theta[2] * Y_2[t-1] - theta[1])/theta[3]) * delta
}
```

```{r}
par(mfrow = c(1,3), mar = c(4,4,2,1))  # 1 row, 3 columns

plot(Y_1, Y_2, type = "l")
plot(Y_1, type = "l")
plot(Y_2, type = "l")
```

## Question 1b

```{r}
# Creating grid
X <- seq(-3, 3, length.out = 100)
Y <- seq(-2, 2, length.out = 100)

snap_to_grid_simple <- function(x, grid) {
  sapply(x, function(xx) {
    if (is.na(xx)) return(NA_real_)
    g <- grid[which.min(abs(grid - xx))]
    return(g)
  })
}

Y1_snap <- snap_to_grid_simple(Y_1, X)
Y2_snap <- snap_to_grid_simple(Y_2, Y)

df <- data.frame(x = Y1_snap, y = Y2_snap)
heat_df <- as.data.frame(table(df))

bin_counts <- hist2d <- hist2d <- function(x, y, xbreaks, ybreaks) {
  counts <- table(
    cut(x, xbreaks, include.lowest = TRUE),
    cut(y, ybreaks, include.lowest = TRUE)
  )
  list(
    x = midpoints(xbreaks),
    y = midpoints(ybreaks),
    z = t(apply(counts, 2, as.numeric))
  )
}
midpoints <- function(breaks) (head(breaks, -1) + tail(breaks, -1)) / 2

h2d <- hist2d(Y_1, Y_2, X, Y)

plot_ly(
  x = h2d$x,
  y = h2d$y,
  z = h2d$z,
  type = "surface",
  colorscale = "Plasma"
) |>
  layout(
    scene = list(
      xaxis = list(title = "Y1"),
      yaxis = list(title = "Y2"),
      zaxis = list(title = "Count", showticklabels = TRUE),
      camera = list(eye = list(x = 1.5, y = 1.5, z = 1))
    )
  )
```

## Part 2: Modelling a building using CSTM-R

```{r}
library(ctsmr)
#Start with simple model for room 4
source("Data/sdeTiTm.R")
load("Data/Exercise3.RData")
```

```{r}
#plotting
library(ggplot2)
library(dplyr)

ggplot(AllDat, aes(x = date, y = yTi4)) +
  geom_line() +
  labs(title = "Room 4 Temperature (yTi4)",
       x = "Date", y = "Temperature (°C)") +
  scale_x_datetime(date_labels = "%Y-%m-%d", date_breaks = "2 week") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(AllDat, aes(x = date)) +
  geom_line(aes(y = yTi4, color = "Room 4 (yTi4)")) +
  geom_line(aes(y = Ta,   color = "Outdoor (Ta)")) +
  labs(title = "Room 4 vs Outdoor Temperature",
       x = "Date", y = "Temperature (°C)", color = "") +
  scale_color_manual(values = c("Room 4 (yTi4)" = "blue", "Outdoor (Ta)" = "red")) +
  scale_x_datetime(date_labels = "%Y-%m-%d", date_breaks = "1 week") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

library(tidyr)

df_plot <- AllDat |> 
  select(date, yTi4, Ta, Ph2, Gv) |> 
  pivot_longer(-date, names_to = "variable", values_to = "value")

ggplot(df_plot, aes(x = date, y = value)) +
  geom_line() +
  facet_wrap(~ variable, scales = "free_y", ncol = 1) +
  labs(title = "Room 4 Related Variables",
       x = "Date", y = "") +
  scale_x_datetime(date_labels = "%Y-%m-%d", date_breaks = "2 weeks") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

library(corrplot)

cor_mat <- cor(AllDat[, c("yTi4", "Ta", "Gv", "Ph1", "Ph2")],
               use = "pairwise.complete.obs")

corrplot(cor_mat,
         method = "color",       # colored squares
         type = "upper",         # only upper triangle
         addCoef.col = "black",  # show correlation coefficients in black
         tl.cex = 1,             # text label size
         number.cex = 0.8,       # coefficient size
         tl.col = "black")        # label color


```

```{r}
library(ggplot2)
library(dplyr)
library(lubridate)

# Extract Hour
Hour <- as.numeric(strftime(AllDat$date, format="%H"))
AllDat$Hour <- Hour
# Create long-format dataframe for faceting
df_plot <- data.frame(
  Hour = rep(AllDat$Hour, 3),
  variable = factor(rep(c("Room 4 (yTi4)", "Outdoor (Ta)", "Solar (Gv)"),
                        each = nrow(AllDat))),
  value = c(AllDat$yTi4, AllDat$Ta, AllDat$Gv)
)

# Compute Hourly mean for each variable
Hourly_mean <- df_plot %>%
  group_by(variable, Hour) %>%
  summarise(mean_val = mean(value, na.rm = TRUE), .groups = "drop")

# Facet scatter plot with mean lines
ggplot(df_plot, aes(x = Hour, y = value)) +
  geom_jitter(width = 0.2, alpha = 0.3, color = "steelblue") +
  geom_line(data = Hourly_mean, aes(x = Hour, y = mean_val), color = "black", size = 1) +
  facet_wrap(~ variable, scales = "free_y", ncol = 1) +
  labs(title = "Hourly Scatter: Room Temperature, Outdoor Temp, and Solar Radiation",
       x = "Hour of Day", y = "") +
  scale_x_continuous(breaks = 0:23) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))



```

```{r}
#First simple model
library("ctsmr")
fit1 <- sdeTiTm(AllDat,AllDat$yTi4,AllDat$Ph2)

```

```{r}
library(dplyr)
library(ggplot2)

# Compute one-step-ahead residuals
Pred_vals <- Pred[[1]]$state$pred$Ti
residuals <- Pred_vals - AllDat$yTi4

# Add to dataframe
df_resid <- AllDat %>%
  mutate(Residual = residuals)

# Plot residuals by hour
ggplot(df_resid, aes(x = Hour, y = Residual)) +
  geom_jitter(width = 0.2, alpha = 0.3, color = "steelblue") +
  stat_summary(fun = mean, geom = "line", aes(group = 1), color = "black", size = 1) +
  scale_x_continuous(breaks = 0:23) +
  labs(title = "Residuals of One-Step-Ahead Prediction by Hour",
       x = "Hour of Day",
       y = "Residual (Predicted - Actual)") +
  theme_minimal()

```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(lubridate)

# Ensure date is POSIXct
AllDat$date <- as.POSIXct(AllDat$date)

# One-step-ahead naive predictor: previous temperature
AllDat <- AllDat %>%
  arrange(date) %>%
  mutate(Naive = lag(yTi4))

# Remove first row (NA in naive) AND first day
first_day <- as.Date(min(AllDat$date))
df_resid_plot <- AllDat %>% 
  slice(-1) %>%                        # remove first row (NA in naive)
  filter(as.Date(date) > first_day)     # remove first day

# Align model predictions to filtered rows
Pred_vals_filtered <- Pred[[1]]$state$pred$Ti[-1]   # skip first prediction
Pred_vals_filtered <- Pred_vals_filtered[
  as.Date(AllDat$date[-1]) > first_day
]

# Compute residuals
df_resid_plot <- df_resid_plot %>%
  mutate(
    Resid_Model = Pred_vals_filtered - yTi4,
    Resid_Naive = Naive - yTi4
  )

# Prepare data in long format for faceting
df_long <- df_resid_plot %>%
  select(date, Resid_Model, Resid_Naive) %>%
  pivot_longer(cols = c(Resid_Model, Resid_Naive),
               names_to = "Predictor", values_to = "Residual") %>%
  mutate(Predictor = factor(Predictor, 
                            levels = c("Resid_Model", "Resid_Naive"),
                            labels = c("Model Residual", "Naive Residual")))

# Compute RMSEs for subtitle
rmse_model <- sqrt(mean(df_resid_plot$Resid_Model^2))
rmse_naive <- sqrt(mean(df_resid_plot$Resid_Naive^2))

# Stacked residual plot
ggplot(df_long, aes(x = date, y = Residual)) +
  geom_line(aes(color = Predictor), size = 1) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  scale_color_manual(values = c("Model Residual" = "#1f77b4",   # blue
                                "Naive Residual" = "#ff7f0e")) + # orange
  facet_wrap(~ Predictor, ncol = 1, scales = "free_y") +
  scale_x_datetime(date_labels = "%Y-%m-%d", date_breaks = "1 week") +
  labs(
    title = "Room 4 Temperature: One-Step-Ahead Residuals",
    subtitle = paste0("RMSE: Model = ", round(rmse_model, 2),
                      " | Naive = ", round(rmse_naive, 2)),
    x = "Date",
    y = "Residual (Predicted - Actual)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")


```
