---
title: "CE2"
format: html
editor: visual
---

## 

# Part 1

## Simulated SETAR

```{r}
set.seed(132)
n <- 3100
r <- rnorm(n)
a0_S <- 3
a1_S <- 0.8
b0_S <- -3
b1_S <- -0.8
thr <- 0
## Make a time series y with a regime model
y_S <- rep(NA,n)
y_S[1] <- r[1]
for(t in 2:n)
  {
    if(y_S[t-1] <= thr)
      {
        y_S[t] <- a0_S + a1_S * y_S[t-1] + r[t]
      }
    else
      {
        y_S[t] <- b0_S + b1_S * y_S[t-1] + r[t]
      }
  }

y_S <- tail(y_S, -100)

ts.plot(y_S, main = "Simulated SETAR(2,1,1)", ylab = expression(y_S[t]))
```

Conditional mean

$$
E_\theta[y_t | y_{t-1}] = (a_0 + a_1y_{t-1})\times1_{y<0} + (b_0 + b_1y_{t-1})\times1_{y\geq0}.
$$

## Parameter Estimation of a1 and b1, SETAR

```{r}

RSSa1b1_SETAR <- function(theta) {
    n <- length(y_S)
    a1_S <- theta[1]
    b1_S <- theta[2]
    
    Q <- 0
    for (t in 2:n) {
      if(y_S[t-1] <= thr)
      {
        mean <- a0_S + a1_S * y_S[t-1] 
      }
    else
      {
        mean <- b0_S + b1_S * y_S[t-1] 
      }
        Q <- Q + (y_S[t] - mean)^2
    }
    return(Q)
}
optim(c(0.5, 0.5), RSSa1b1_SETAR)

```

## Estimation of threshold

```{r}
RSSthr_SETAR <- function(theta) {
    n <- length(y_S)
    thr <- theta[1]

    Q <- 0
    for (t in 2:n) {
      if(y_S[t-1] <= thr)
      {
        mean <- a0_S + a1_S * y_S[t-1] 
      }
    else
      {
        mean <- b0_S + b1_S * y_S[t-1] 
      }
        Q <- Q + (y_S[t] - mean)^2
    }
    return(Q)
}
optim(c(1), RSSthr_SETAR, method = 'Brent', lower = min(y_S), upper = max(y_S))

```

## Full estimation

```{r}
RSSall_SETAR <- function(theta) {
    n <- length(y_S)
    a0_S <- theta[1]
    a1_S <- theta[2]
    b0_S <- theta[3]
    b1_S <- theta[4]
    thr <- theta[5]
    
    Q <- 0
    for (t in 2:n) {
      if(y_S[t-1] <= thr)
      {
        mean <- a0_S + a1_S * y_S[t-1] 
      }
    else
      {
        mean <- b0_S + b1_S * y_S[t-1] 
      }
        Q <- Q + (y_S[t] - mean)^2
    }
    return(Q)
}
optim(c(0.5, 0.5, 0.5, 0.5, 0.5), RSSall_SETAR)
```

```         
```

## Simulated IGAR

```{r}
set.seed(41)
n <- 3100
a0_I <- 3
a1_I <- 0.8
b0_I <- -1
b1_I <- -0.2
p <- 0.3

r <- rnorm(n)
y_I <- rep(NA,n)
y_I[1] <- r[1]
for(t in 2:n)
  {
    if(rbinom(1,1,p) == 1)
      {
        y_I[t] <- a0_I + a1_I * y_I[t-1] + r[t]
      }
    else
      {
        y_I[t] <- b0_I + b1_I * y_I[t-1] + r[t]
      }
}

y_I <- tail(y_I, -100)

ts.plot(y_I, main = "Simulated IGAR(2,1)", ylab = expression(y_I[t]))
```

Conditional mean

$$
E_\theta[y_t | y_{t-1}] = p (1 + ay_{t-1}) + (1-p)(1 + by_{t-1}).
$$

## Parameter Estimation of a and b, IGAR

```{r}
RSSa1b1_IGAR <- function(theta) {
    n <- length(y_I)
    a1_I <- theta[1]
    b1_I <- theta[2]
    
    Q <- 0
    for (t in 2:n) {
        mean = p*(a0_I + a1_I*y_I[t-1]) + (1-p)*(b0_I+b1_I*y_I[t-1])
        Q <- Q + (y_I[t] - mean)^2
    }
    return(Q)
}
optim(c(0.5, 0.5), RSSa1b1_IGAR)
```

## Estimation of p

```{r}
RSSp_IGAR <- function(theta) {
    n <- length(y_I)
    p <- theta[1]
    
    Q <- 0
    for (t in 2:n) {
        mean = p*(a0_I + a1_I * y_I[t-1]) + (1-p) * (b0_I + b1_I * y_I[t-1])
        Q <- Q + (y_I[t] - mean)^2
    }
    return(Q)
}

optim(c(0.5), RSSp_IGAR, method='Brent', lower=0, upper=1)
```

## Full estimation

```{r}
RSSall_IGAR <- function(theta) {
    n <- length(y_I)
    a0_I <- theta[1]
    a1_I <- theta[2]
    b0_I <- theta[3]
    b1_I <- theta[4]
    p <- theta[5]

    
    Q <- 0
    for (t in 2:n) {
        mean = p*(a0_I + a1_I*y_I[t-1]) + (1-p)*(b0_I+b1_I*y_I[t-1])
        Q <- Q + (y_I[t] - mean)^2
    }
    return(Q)
}

optim(c(0.5, 0.5, 0.5, 0.5, 0.5), RSSall_IGAR)
```

# Part 2

## SETAR

```{r}
# Function for estimating unknown parameters

RSSa1b1_SETAR <- function(theta, y_S) {
    n <- length(y_S)
    a1_S <- theta[1]
    b1_S <- theta[2]
    
    Q <- 0
    for (t in 2:n) {
      if(y_S[t-1] <= thr)
      {
        mean <- a0_S + a1_S * y_S[t-1] 
      }
    else
      {
        mean <- b0_S + b1_S * y_S[t-1] 
      }
        Q <- Q + (y_S[t] - mean)^2
    }
    return(Q)
}

# Sub intervals of y

ysub <- list(
ysub1 <- y_S[1:3000],
ysub2 <- y_S[1:300],
ysub3 <- y_S[1:30],
ysub4 <- y_S[1001:1300],
ysub5 <- y_S[1001:1030]
)
names(ysub) <- paste0("ysub", seq_along(ysub))

steps <- 100
# Create grid of points
X <- seq(0, 1, length.out = steps)
Y <- seq(-1, 0, length.out = steps)

# Evaluate RSSa1b1 over grid for all ysub

for (i in 1:length(ysub)) {

  Zi <- outer(X, Y, Vectorize(function(h, t) RSSa1b1_SETAR(c(h, t), ysub[[i]])))

  filled.contour(
    X, Y, Zi,
    xlab = expression(a[1]),
    ylab = expression(b[1]),
    main = bquote("RSS(" * a[1] * ", " * b[1] * ") for " * .(names(ysub)[i])),
    nlevels = 30,
    color.palette = colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
)
}
```

## IGAR

```{r}
# Function for estimating unknown parameters
RSSa1b1_IGAR <- function(theta, y_I) {
    n <- length(y_I)
    a1_I <- theta[1]
    b1_I <- theta[2]
    
    Q <- 0
    for (t in 2:n) {
        mean = p*(a0_I + a1_I*y_I[t-1]) + (1-p)*(b0_I+b1_I*y_I[t-1])
        Q <- Q + (y_I[t] - mean)^2
    }
    return(Q)
}

ysub <- list(
ysub1 <- y_I[1:3000],
ysub2 <- y_I[1:300],
ysub3 <- y_I[1:30],
ysub4 <- y_I[1001:1300],
ysub5 <- y_I[1001:1030]
)
names(ysub) <- paste0("ysub", seq_along(ysub))

steps <- 100
# Create grid of points
X <- seq(0, 1, length.out = steps)
Y <- seq(-1, 0, length.out = steps)

for (i in 1:length(ysub)) {
  # Evaluate RSSa1b1 over grid
  Zi <- outer(X, Y, Vectorize(function(h, t) RSSa1b1_IGAR(c(h, t), ysub[[i]])))

  filled.contour(
    X, Y, Zi,
    xlab = expression(a[1]),
    ylab = expression(b[1]),
    main = bquote("RSS(" * a[1] * ", " * b[1] * ") for " * .(names(ysub)[i])),
    nlevels = 30,
    color.palette = colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
)
}
```

## Fitting line of parameters

```{r}
y_t <- y_I[2:3000] # present value
y_t1 <- y_I[1:2999] # one lag value
y_df <- data.frame(y_t, y_t1)
ols <- lm(y_t ~ y_t1, data = y_df) # ordinary least squares estimate
b_ols <-  function(a1) (as.numeric(ols$coefficients[2]) - p*a1)/(1-p) # slope estimate as function of a

Z <- outer(X, Y, Vectorize(function(h, t) RSSa1b1_IGAR(c(h, t), ysub[[1]])))

filled.contour(
  X, Y, Z,
  xlab = expression(a[1]),
  ylab = expression(b[1]),
  main = bquote("RSS(" * a[1] * ", " * b[1] * ") for " * .(names(ysub)[1])),
  nlevels = 30,
  color.palette = colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000")),
  plot.axes = {
    axis(1); axis(2) 
    lines(X, b_ols(X), lwd=2)} # adding line 
  )
```

# Part 3

```{r}
set.seed(5)
n <- 1000

############################################################
## Example run (mixture)
sigmae <- 1
sigmac <- 0.1
e <- rnorm(n,0,sigmae)
c <- rnorm(n,0,sigmac)
mu <- 0.1
phi <- -0.5
Phi <- numeric(n)
Phi[1] <- 0.1
y <- numeric(n)
y[1] <- e[1]

for(t in 2:n){
    Phi[t] <- phi*Phi[t-1] + mu*(1-phi) + c[t]
    y[t] <- Phi[t] * y[t-1] + e[t]
}

# Save plots
png("example_Phi_full.png", width=800, height=600)
plot(1:n, Phi, type="l", main="Phi (full process)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("example_y_full.png", width=800, height=600)
plot(1:n, y,   type="l", main="y (full process)", xlab="t", ylab="y_t (observed)")
dev.off()

png("example_Phi_zoom.png", width=800, height=600)
plot(900:1000, Phi[900:1000], type="l", main="Phi (t=900–1000)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("example_y_zoom.png", width=800, height=600)
plot(900:1000, y[900:1000],  type="l", main="y (t=900–1000)", xlab="t", ylab="y_t (observed)")
dev.off()

############################################################
## Drift dominates
sigmae <- 1
sigmac <- 0.1
e <- rnorm(n,0,sigmae)
c <- rnorm(n,0,sigmac)
mu <- 0.8
phi <- 0.01
Phi <- numeric(n)
Phi[1] <- 0.1
y <- numeric(n)
y[1] <- e[1]

for(t in 2:n){
    Phi[t] <- phi*Phi[t-1] + mu*(1-phi) + c[t]
    y[t] <- Phi[t] * y[t-1] + e[t]
}

png("drift_Phi_full.png", width=800, height=600)
plot(1:n, Phi, type="l", main="Phi (full process)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("drift_y_full.png", width=800, height=600)
plot(1:n, y,   type="l", main="y (full process)", xlab="t", ylab="y_t (observed)")
dev.off()

png("drift_Phi_zoom.png", width=800, height=600)
plot(900:1000, Phi[900:1000], type="l", main="Phi (drift dominates, t=900–1000)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("drift_y_zoom.png", width=800, height=600)
plot(900:1000, y[900:1000],  type="l", main="y (drift dominates, t=900–1000)", xlab="t", ylab="y_t (observed)")
dev.off()

############################################################
## Phi dominates
sigmae <- 1
sigmac <- 0.1
e <- rnorm(n,0,sigmae)
c <- rnorm(n,0,sigmac)
mu <- 0
phi <- 0.95
Phi <- numeric(n)
Phi[1] <- 0
y <- numeric(n)
y[1] <- e[1]

for(t in 2:n){
    Phi[t] <- phi*Phi[t-1] + mu*(1-phi) + c[t]
    y[t] <- Phi[t] * y[t-1] + e[t]
}

png("phi_Phi_full.png", width=800, height=600)
plot(1:n, Phi, type="l", main="Phi (full process)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("phi_y_full.png", width=800, height=600)
plot(1:n, y,   type="l", main="y (full process)", xlab="t", ylab="y_t (observed)")
dev.off()

png("phi_Phi_zoom.png", width=800, height=600)
plot(900:1000, Phi[900:1000], type="l", main="Phi (t=900–1000)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("phi_y_zoom.png", width=800, height=600)
plot(900:1000, y[900:1000],  type="l", main="y (t=900–1000)", xlab="t", ylab="y_t (observed)")
dev.off()

############################################################
## Noisy
sigmae <- 1
sigmac <- 0.2
e <- rnorm(n,0,sigmae)
c <- rnorm(n,0,sigmac)
mu <- 0
phi <- 0.95
Phi <- numeric(n)
Phi[1] <- 0
y <- numeric(n)
y[1] <- e[1]

for(t in 2:n){
    Phi[t] <- phi*Phi[t-1] + mu*(1-phi) + c[t]
    y[t] <- Phi[t] * y[t-1] + e[t]
}

png("noise_Phi_full.png", width=800, height=600)
plot(1:n, Phi, type="l", main="Phi (full process)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("noise_y_full.png", width=800, height=600)
plot(1:n, y,   type="l", main="y (full process)", xlab="t", ylab="y_t (observed)")
dev.off()

png("noise_Phi_zoom.png", width=800, height=600)
plot(900:1000, Phi[900:1000], type="l", main="Phi (t=900–1000)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("noise_y_zoom.png", width=800, height=600)
plot(900:1000, y[900:1000],  type="l", main="y (t=900–1000)", xlab="t", ylab="y_t (observed)")
dev.off()


```

```{r}
## Negative Phi
sigmae <- 1
sigmac <- 0.1
e <- rnorm(n,0,sigmae)
c <- rnorm(n,0,sigmac)
mu <- 0
phi <- -0.95
Phi <- numeric(n)
Phi[1] <- 0
y <- numeric(n)
y[1] <- e[1]

for(t in 2:n){
    Phi[t] <- phi*Phi[t-1] + mu*(1-phi) + c[t]
    y[t] <- Phi[t] * y[t-1] + e[t]
}

png("neg_Phi_full.png", width=800, height=600)
plot(1:n, Phi, type="l", main="Phi (full process)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("neg_y_full.png", width=800, height=600)
plot(1:n, y,   type="l", main="y (full process)", xlab="t", ylab="y_t (observed)")
dev.off()

png("neg_Phi_zoom.png", width=800, height=600)
plot(900:1000, Phi[900:1000], type="l", main="Phi (t=900–1000)", xlab="t", ylab="Phi_t (latent)")
dev.off()

png("neg_y_zoom.png", width=800, height=600)
plot(900:1000, y[900:1000],  type="l", main="y (t=900–1000)", xlab="t", ylab="y_t (observed)")
dev.off()

```

# Part 4

```{r}
a <- 0.4
sim_length <- 1000
num_sims <- 20
process_var <- 1
obs_var <- 1

sims <- vector(mode='list', length=num_sims)
for (i in 1:num_sims) {
    sim <- numeric(length=sim_length)
    sim[1] <- rnorm(1, mean=0, sd=sqrt(process_var))
    for (j in 2:sim_length) {
        sim[j] <- a * sim[j-1] + rnorm(1, mean=0, sd=sqrt(process_var))
    }
    sims[[i]] = sim + rnorm(sim_length, mean=0, sd=sqrt(obs_var))
}

plot(sims[[1]], type='l')
```

```{r}
a_var <- 1
process_var <- 1
R1 <- matrix(c(process_var, 0, 0, 0), nrow=2, ncol=2)

x = matrix(nrow=2, ncol=sim_length)
x[1,1] <- rnorm(1, mean=0, sd=sqrt(process_var))
x[2,1] <- rnorm(1, mean=0, sd=sqrt(a_var))
P <- matrix(c(process_var, 0, 0, a_var), nrow=2, ncol=2)
f <- function(x) { return(matrix(c(x[1]*x[2], x[2])))}
F <- function(x) { return(matrix(c(x[2], 0, x[1], 1), ncol=2, nrow=2)) }
h <- function(x) { return(x[1]) }
H <- function (x) { return(matrix(c(1, 0), ncol=2)) }
    
i = 1
for (t in 2:sim_length) {
    xt = f(x[, t-1])
    P = F(x[,t-1]) %*% P %*% t(F(x[,t-1])) + R1
    
    res = sims[[i]][t] - xt[1]
    K = P %*% t(H(x[,t-1])) %*% solve(H(x[,t-1]) %*% P %*% t(H(x[,t-1])) + obs_var)
    xt = xt + K * res
    P = (diag(2) - K %*% H(x[,t-1])) %*% P
    
    x[,t] = xt
}

par(mfrow = c(2, 1),        # two rows, one column
    mar = c(4, 4, 2, 1))    # smaller margins

plot(x[1, ], type = "l", col = "steelblue", lwd = 2,
     main = expression("State 1: " ~ x[1]),
     xlab = "Time", ylab = "x[1]")

plot(x[2, ], type = "l", col = "darkred", lwd = 2,
     main = expression("State 2: " ~ x[2]),
     xlab = "Time", ylab = "x[2]")
abline(h = 0.4)
```

```{r}
estimate_a <- function(data) {
    burn_in <- 500
    a_var <- 1
    R1 <- matrix(c(process_var, 0, 0, 0), nrow=2, ncol=2)
    
    x = matrix(nrow=2, ncol=sim_length)
    x[1,1] <- rnorm(1, mean=0, sd=sqrt(process_var))
    x[2,1] <- rnorm(1, mean=0, sd=sqrt(a_var))
    P <- matrix(c(process_var, 0, 0, a_var), nrow=2, ncol=2)
    f <- function(x) { return(matrix(c(x[1]*x[2], x[2])))}
    F <- function(x) { return(matrix(c(x[2], 0, x[1], 1), ncol=2, nrow=2)) }
    h <- function(x) { return(x[1]) }
    H <- function (x) { return(matrix(c(1, 0), ncol=2)) }
        
    for (t in 2:sim_length) {
        xt = f(x[, t-1])
        P = F(x[,t-1]) %*% P %*% t(F(x[,t-1])) + R1
        
        res = data[t] - xt[1]
        K = P %*% t(H(x[,t-1])) %*% solve(H(x[,t-1]) %*% P %*% t(H(x[,t-1])) + obs_var)
        xt = xt + K * res
        P = (diag(2) - K %*% H(x[,t-1])) %*% P
        
        x[,t] = xt
    }
    return(mean(x[2,burn_in:sim_length]))
}

estimates <- numeric(20)
for (i in 1:20) {
  estimates[i] <- estimate_a(sims[[i]])
}
quantile(estimates, probs = c(0.025, 0.5, 0.975))
boxplot(estimates, horizontal = TRUE)
```
